#include<stdio.h>
/*
    进阶篇
    整型数据的存储
*/

void CheckMulByte(){
    int test=0x00000001;       //大端:00000001 小端:01000000
    if(*(char*)&test)
        printf("当前机器采用小端字节序\n");
    else
        printf("当前机器采用大端字节序\n");
}

void test1(){                      
    signed char a=-1;              
    unsigned char b=-1;            
    char c=-1;
    //为了方便计算，过程可以忽略大小端的存储顺序，但涉及到高低位取值时要正确
    /*
    -1原码：10000000 00000000 00000000 00000001
      反码：11111111 11111111 11111111 11111110
      补码：11111111 11111111 11111111 11111111
    截断后：11111111

有符号char：11111111
  整型提升：11111111 11111111 11111111 11111111
有符号整型：10000000 00000000 00000000 000000001 = -1

无符号char：11111111
  整型提升：00000000 00000000 00000000 11111111
有符号整型：00000000 00000000 00000000 11111111 = 255

char 默认为有符号，所以 = -1

所以最终结果:-1,255,-1
    */                 
    printf("%d,%d,%d\n",a,b,c);       //%d有符号整数
}

void test2(){
    char a = -128;            //char 默认有符号
    /*
    -128原码：10000000 00000000 00000000 10000000
        反码：11111111 11111111 11111111 01111111
        补码：11111111 11111111 11111111 10000000
      截断后：10000000

  有符号char: 10000000
    整型提升: 11111111 11111111 11111111 10000000
  无符号整型：11111111 11111111 11111111 10000000 = 一个非常大的正整数
    */
    printf("%u\n",a);              //以无符号整型形式输出
}

void test3(){
    char a = 128;
    /*
        128原码：00000000 00000000 00000000 10000000
           反码：00000000 00000000 00000000 10000000
           补码：00000000 00000000 00000000 10000000
         截断后：10000000

        整型提升：11111111 11111111 11111111 10000000
       有符号整型：10000000 00000000 00000000 10000000 = -128
       无符号整型：11111111 11111111 11111111 10000000 = 一个很大的正整数

       最终结果:-128 一个很大的正整数
    */
    printf("%d\n",a);   
    printf("%u\n",a);   
}

int main(){
    CheckMulByte();
    test1();
    test2();
    test3();

    return 0;
}